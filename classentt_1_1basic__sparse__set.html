<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>EnTT: entt::basic_sparse_set&lt; Entity, Allocator &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">EnTT<span id="projectnumber">&#160;3.12.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceentt.html">entt</a></li><li class="navelem"><a class="el" href="classentt_1_1basic__sparse__set.html">basic_sparse_set</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classentt_1_1basic__sparse__set-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">entt::basic_sparse_set&lt; Entity, Allocator &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Basic sparse set implementation.  
 <a href="classentt_1_1basic__sparse__set.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for entt::basic_sparse_set&lt; Entity, Allocator &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classentt_1_1basic__sparse__set__inherit__graph.png" border="0" usemap="#aentt_1_1basic__sparse__set_3_01Entity_00_01Allocator_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="aentt_1_1basic__sparse__set_3_01Entity_00_01Allocator_01_4_inherit__map" id="aentt_1_1basic__sparse__set_3_01Entity_00_01Allocator_01_4_inherit__map">
<area shape="rect" title="Basic sparse set implementation." alt="" coords="5,49,169,89"/>
<area shape="rect" href="classentt_1_1basic__storage.html" title=" " alt="" coords="227,5,389,60"/>
<area shape="rect" href="classentt_1_1basic__storage_3_01Entity_00_01Entity_00_01Allocator_01_4.html" title="Swap&#45;only entity storage specialization." alt="" coords="217,85,399,125"/>
<area shape="rect" href="classentt_1_1basic__observer.html" title="Observer." alt="" coords="447,13,640,53"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ac1f56bb6b949b338ddad09977c631706"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#ac1f56bb6b949b338ddad09977c631706">traits_type</a> = <a class="el" href="structentt_1_1entt__traits.html">entt_traits</a>&lt; Entity &gt;</td></tr>
<tr class="memdesc:ac1f56bb6b949b338ddad09977c631706"><td class="mdescLeft">&#160;</td><td class="mdescRight">Entity traits.  <br /></td></tr>
<tr class="separator:ac1f56bb6b949b338ddad09977c631706"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae90adeddf9bab1f9c8b4b1fff95980f0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#ae90adeddf9bab1f9c8b4b1fff95980f0">entity_type</a> = typename <a class="el" href="classentt_1_1basic__entt__traits.html#a8d3ccdc302fc7dc567541fa12eca6b4e">traits_type::value_type</a></td></tr>
<tr class="memdesc:ae90adeddf9bab1f9c8b4b1fff95980f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Underlying entity identifier.  <br /></td></tr>
<tr class="separator:ae90adeddf9bab1f9c8b4b1fff95980f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14e627591924feaaad4f04d13c4f4b2d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#a14e627591924feaaad4f04d13c4f4b2d">version_type</a> = typename <a class="el" href="classentt_1_1basic__entt__traits.html#aa3fe33d19b228d07c5560b907f910c10">traits_type::version_type</a></td></tr>
<tr class="memdesc:a14e627591924feaaad4f04d13c4f4b2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Underlying version type.  <br /></td></tr>
<tr class="separator:a14e627591924feaaad4f04d13c4f4b2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ec9530d8aa9ac94d421b27eb6998edb"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#a2ec9530d8aa9ac94d421b27eb6998edb">size_type</a> = std::size_t</td></tr>
<tr class="memdesc:a2ec9530d8aa9ac94d421b27eb6998edb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned integer type.  <br /></td></tr>
<tr class="separator:a2ec9530d8aa9ac94d421b27eb6998edb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6faaccfb0c465afb6173b0fb8a37069"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#af6faaccfb0c465afb6173b0fb8a37069">allocator_type</a> = Allocator</td></tr>
<tr class="memdesc:af6faaccfb0c465afb6173b0fb8a37069"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocator type.  <br /></td></tr>
<tr class="separator:af6faaccfb0c465afb6173b0fb8a37069"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b18963e68d4f003e19389fd342f90cc"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#a8b18963e68d4f003e19389fd342f90cc">pointer</a> = typename packed_container_type::const_pointer</td></tr>
<tr class="memdesc:a8b18963e68d4f003e19389fd342f90cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer type to contained entities.  <br /></td></tr>
<tr class="separator:a8b18963e68d4f003e19389fd342f90cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cea231ae7386a12487164d918f632b0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#a6cea231ae7386a12487164d918f632b0">iterator</a> = <a class="el" href="classentt_1_1basic__sparse__set.html#ac56bb654b47a648d64a754d85c70b40a">basic_iterator</a></td></tr>
<tr class="memdesc:a6cea231ae7386a12487164d918f632b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Random access iterator type.  <br /></td></tr>
<tr class="separator:a6cea231ae7386a12487164d918f632b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3688979d568f2450725d69aa89571f4f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#a3688979d568f2450725d69aa89571f4f">const_iterator</a> = <a class="el" href="classentt_1_1basic__sparse__set.html#a6cea231ae7386a12487164d918f632b0">iterator</a></td></tr>
<tr class="memdesc:a3688979d568f2450725d69aa89571f4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant random access iterator type.  <br /></td></tr>
<tr class="separator:a3688979d568f2450725d69aa89571f4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe62c143e816cf5e12078a607966c003"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#afe62c143e816cf5e12078a607966c003">reverse_iterator</a> = std::reverse_iterator&lt; <a class="el" href="classentt_1_1basic__sparse__set.html#a6cea231ae7386a12487164d918f632b0">iterator</a> &gt;</td></tr>
<tr class="memdesc:afe62c143e816cf5e12078a607966c003"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse iterator type.  <br /></td></tr>
<tr class="separator:afe62c143e816cf5e12078a607966c003"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27d66fda0fba1587a5f61e9c16f742f7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#a27d66fda0fba1587a5f61e9c16f742f7">const_reverse_iterator</a> = std::reverse_iterator&lt; <a class="el" href="classentt_1_1basic__sparse__set.html#a3688979d568f2450725d69aa89571f4f">const_iterator</a> &gt;</td></tr>
<tr class="memdesc:a27d66fda0fba1587a5f61e9c16f742f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant reverse iterator type.  <br /></td></tr>
<tr class="separator:a27d66fda0fba1587a5f61e9c16f742f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:afc504894fc2c20ea25b7fc2864bd22e3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#afc504894fc2c20ea25b7fc2864bd22e3">basic_sparse_set</a> ()</td></tr>
<tr class="memdesc:afc504894fc2c20ea25b7fc2864bd22e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <br /></td></tr>
<tr class="separator:afc504894fc2c20ea25b7fc2864bd22e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b636566df9e6f3f36ff62d2bdde8d10"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#a1b636566df9e6f3f36ff62d2bdde8d10">basic_sparse_set</a> (const <a class="el" href="classentt_1_1basic__sparse__set.html#af6faaccfb0c465afb6173b0fb8a37069">allocator_type</a> &amp;allocator)</td></tr>
<tr class="memdesc:a1b636566df9e6f3f36ff62d2bdde8d10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an empty container with a given allocator.  <br /></td></tr>
<tr class="separator:a1b636566df9e6f3f36ff62d2bdde8d10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e264ab5a7e2d97a204004d25b14238b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#a8e264ab5a7e2d97a204004d25b14238b">basic_sparse_set</a> (<a class="el" href="namespaceentt.html#abc4d0fa77fae26e7c01793990996c581">deletion_policy</a> pol, const <a class="el" href="classentt_1_1basic__sparse__set.html#af6faaccfb0c465afb6173b0fb8a37069">allocator_type</a> &amp;allocator={})</td></tr>
<tr class="memdesc:a8e264ab5a7e2d97a204004d25b14238b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an empty container with the given policy and allocator.  <br /></td></tr>
<tr class="separator:a8e264ab5a7e2d97a204004d25b14238b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5d35aae661fb35e485ac733969c84d9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#af5d35aae661fb35e485ac733969c84d9">basic_sparse_set</a> (const <a class="el" href="structentt_1_1type__info.html">type_info</a> &amp;elem, <a class="el" href="namespaceentt.html#abc4d0fa77fae26e7c01793990996c581">deletion_policy</a> pol=<a class="el" href="namespaceentt.html#abc4d0fa77fae26e7c01793990996c581a8223d1ccb16b6dd0b19fe9c6fdb13708">deletion_policy::swap_and_pop</a>, const <a class="el" href="classentt_1_1basic__sparse__set.html#af6faaccfb0c465afb6173b0fb8a37069">allocator_type</a> &amp;allocator={})</td></tr>
<tr class="memdesc:af5d35aae661fb35e485ac733969c84d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an empty container with the given value type, policy and allocator.  <br /></td></tr>
<tr class="separator:af5d35aae661fb35e485ac733969c84d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf4d881833f592ed21079e2a0fac8d2a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#aaf4d881833f592ed21079e2a0fac8d2a">basic_sparse_set</a> (<a class="el" href="classentt_1_1basic__sparse__set.html">basic_sparse_set</a> &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:aaf4d881833f592ed21079e2a0fac8d2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor.  <br /></td></tr>
<tr class="separator:aaf4d881833f592ed21079e2a0fac8d2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c61f0d7c13b938d3524f0fe7f9c3a75"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#a8c61f0d7c13b938d3524f0fe7f9c3a75">basic_sparse_set</a> (<a class="el" href="classentt_1_1basic__sparse__set.html">basic_sparse_set</a> &amp;&amp;other, const <a class="el" href="classentt_1_1basic__sparse__set.html#af6faaccfb0c465afb6173b0fb8a37069">allocator_type</a> &amp;allocator) noexcept</td></tr>
<tr class="memdesc:a8c61f0d7c13b938d3524f0fe7f9c3a75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocator-extended move constructor.  <br /></td></tr>
<tr class="separator:a8c61f0d7c13b938d3524f0fe7f9c3a75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac56f048f614c38f14b19ba9cb27faa94"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#ac56f048f614c38f14b19ba9cb27faa94">~basic_sparse_set</a> ()</td></tr>
<tr class="memdesc:ac56f048f614c38f14b19ba9cb27faa94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default destructor.  <br /></td></tr>
<tr class="separator:ac56f048f614c38f14b19ba9cb27faa94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53f8aad7f89c040a3ef0e79ad9e814fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1basic__sparse__set.html">basic_sparse_set</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#a53f8aad7f89c040a3ef0e79ad9e814fb">operator=</a> (<a class="el" href="classentt_1_1basic__sparse__set.html">basic_sparse_set</a> &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:a53f8aad7f89c040a3ef0e79ad9e814fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator.  <br /></td></tr>
<tr class="separator:a53f8aad7f89c040a3ef0e79ad9e814fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ba4866849ffb525cce7b4eee58b83a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#a0ba4866849ffb525cce7b4eee58b83a8">swap</a> (<a class="el" href="classentt_1_1basic__sparse__set.html">basic_sparse_set</a> &amp;other)</td></tr>
<tr class="memdesc:a0ba4866849ffb525cce7b4eee58b83a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchanges the contents with those of a given sparse set.  <br /></td></tr>
<tr class="separator:a0ba4866849ffb525cce7b4eee58b83a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab292b60dd8782739701906aec8f381ab"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classentt_1_1basic__sparse__set.html#af6faaccfb0c465afb6173b0fb8a37069">allocator_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#ab292b60dd8782739701906aec8f381ab">get_allocator</a> () const noexcept</td></tr>
<tr class="memdesc:ab292b60dd8782739701906aec8f381ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the associated allocator.  <br /></td></tr>
<tr class="separator:ab292b60dd8782739701906aec8f381ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91f80e4333c16c6c3786b041c8a7e8a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceentt.html#abc4d0fa77fae26e7c01793990996c581">deletion_policy</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#a91f80e4333c16c6c3786b041c8a7e8a2">policy</a> () const noexcept</td></tr>
<tr class="memdesc:a91f80e4333c16c6c3786b041c8a7e8a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the deletion policy of a sparse set.  <br /></td></tr>
<tr class="separator:a91f80e4333c16c6c3786b041c8a7e8a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58d49df52ee3133a1347dc01131a4f1a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#a58d49df52ee3133a1347dc01131a4f1a">reserve</a> (const <a class="el" href="classentt_1_1basic__sparse__set.html#a2ec9530d8aa9ac94d421b27eb6998edb">size_type</a> cap)</td></tr>
<tr class="memdesc:a58d49df52ee3133a1347dc01131a4f1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increases the capacity of a sparse set.  <br /></td></tr>
<tr class="separator:a58d49df52ee3133a1347dc01131a4f1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17b25baaceb061cd93da56f1ec24ee98"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classentt_1_1basic__sparse__set.html#a2ec9530d8aa9ac94d421b27eb6998edb">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#a17b25baaceb061cd93da56f1ec24ee98">capacity</a> () const noexcept</td></tr>
<tr class="memdesc:a17b25baaceb061cd93da56f1ec24ee98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements that a sparse set has currently allocated space for.  <br /></td></tr>
<tr class="separator:a17b25baaceb061cd93da56f1ec24ee98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e10cc6ddc7ef9c733aabdec849c5b79"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#a7e10cc6ddc7ef9c733aabdec849c5b79">shrink_to_fit</a> ()</td></tr>
<tr class="memdesc:a7e10cc6ddc7ef9c733aabdec849c5b79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Requests the removal of unused capacity.  <br /></td></tr>
<tr class="separator:a7e10cc6ddc7ef9c733aabdec849c5b79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e51c3904b0581866f8791a04435fc5f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1basic__sparse__set.html#a2ec9530d8aa9ac94d421b27eb6998edb">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#a7e51c3904b0581866f8791a04435fc5f">extent</a> () const noexcept</td></tr>
<tr class="memdesc:a7e51c3904b0581866f8791a04435fc5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the extent of a sparse set.  <br /></td></tr>
<tr class="separator:a7e51c3904b0581866f8791a04435fc5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69ad0662838fd351985a51ee3017fb6c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1basic__sparse__set.html#a2ec9530d8aa9ac94d421b27eb6998edb">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#a69ad0662838fd351985a51ee3017fb6c">size</a> () const noexcept</td></tr>
<tr class="memdesc:a69ad0662838fd351985a51ee3017fb6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements in a sparse set.  <br /></td></tr>
<tr class="separator:a69ad0662838fd351985a51ee3017fb6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8936d80c3656449118a7a7a08be6258"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#ad8936d80c3656449118a7a7a08be6258">empty</a> () const noexcept</td></tr>
<tr class="memdesc:ad8936d80c3656449118a7a7a08be6258"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether a sparse set is empty.  <br /></td></tr>
<tr class="separator:ad8936d80c3656449118a7a7a08be6258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a736ba15d734ea65f18e3c1fd5d748e5e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#a736ba15d734ea65f18e3c1fd5d748e5e">contiguous</a> () const noexcept</td></tr>
<tr class="memdesc:a736ba15d734ea65f18e3c1fd5d748e5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether a sparse set is fully packed.  <br /></td></tr>
<tr class="separator:a736ba15d734ea65f18e3c1fd5d748e5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c540ff32bca204b1adbd9e4f4a0240b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1basic__sparse__set.html#a8b18963e68d4f003e19389fd342f90cc">pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#a4c540ff32bca204b1adbd9e4f4a0240b">data</a> () const noexcept</td></tr>
<tr class="memdesc:a4c540ff32bca204b1adbd9e4f4a0240b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct access to the internal packed array.  <br /></td></tr>
<tr class="separator:a4c540ff32bca204b1adbd9e4f4a0240b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6e986a41090a43eb6bbdc22bf8eb472"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1basic__sparse__set.html#a3688979d568f2450725d69aa89571f4f">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#af6e986a41090a43eb6bbdc22bf8eb472">begin</a> () const noexcept</td></tr>
<tr class="memdesc:af6e986a41090a43eb6bbdc22bf8eb472"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the beginning.  <br /></td></tr>
<tr class="separator:af6e986a41090a43eb6bbdc22bf8eb472"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1934fc85ed01c3528c45ab9a76712fa7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1basic__sparse__set.html#a3688979d568f2450725d69aa89571f4f">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#a1934fc85ed01c3528c45ab9a76712fa7">cbegin</a> () const noexcept</td></tr>
<tr class="memdesc:a1934fc85ed01c3528c45ab9a76712fa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the beginning.    <br /></td></tr>
<tr class="separator:a1934fc85ed01c3528c45ab9a76712fa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3187a76bdb963346a715e0ebd833bfd7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1basic__sparse__set.html#a6cea231ae7386a12487164d918f632b0">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#a3187a76bdb963346a715e0ebd833bfd7">end</a> () const noexcept</td></tr>
<tr class="memdesc:a3187a76bdb963346a715e0ebd833bfd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the end.  <br /></td></tr>
<tr class="separator:a3187a76bdb963346a715e0ebd833bfd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f0cc6e746fd49b0c7a0b8e5d8504fef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1basic__sparse__set.html#a3688979d568f2450725d69aa89571f4f">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#a9f0cc6e746fd49b0c7a0b8e5d8504fef">cend</a> () const noexcept</td></tr>
<tr class="memdesc:a9f0cc6e746fd49b0c7a0b8e5d8504fef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the end.    <br /></td></tr>
<tr class="separator:a9f0cc6e746fd49b0c7a0b8e5d8504fef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a365e15bdab3308c58af3c03376cce1ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1basic__sparse__set.html#a27d66fda0fba1587a5f61e9c16f742f7">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#a365e15bdab3308c58af3c03376cce1ec">rbegin</a> () const noexcept</td></tr>
<tr class="memdesc:a365e15bdab3308c58af3c03376cce1ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the beginning.  <br /></td></tr>
<tr class="separator:a365e15bdab3308c58af3c03376cce1ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad57b82c12d92837a14d8904e82eb49a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1basic__sparse__set.html#a27d66fda0fba1587a5f61e9c16f742f7">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#ad57b82c12d92837a14d8904e82eb49a9">crbegin</a> () const noexcept</td></tr>
<tr class="memdesc:ad57b82c12d92837a14d8904e82eb49a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the beginning.    <br /></td></tr>
<tr class="separator:ad57b82c12d92837a14d8904e82eb49a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a408ae201025279196f63ef32cf58da9a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1basic__sparse__set.html#afe62c143e816cf5e12078a607966c003">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#a408ae201025279196f63ef32cf58da9a">rend</a> () const noexcept</td></tr>
<tr class="memdesc:a408ae201025279196f63ef32cf58da9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the end.  <br /></td></tr>
<tr class="separator:a408ae201025279196f63ef32cf58da9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab28f2f1c7bbf2861f4a3e7602a317b96"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1basic__sparse__set.html#a27d66fda0fba1587a5f61e9c16f742f7">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#ab28f2f1c7bbf2861f4a3e7602a317b96">crend</a> () const noexcept</td></tr>
<tr class="memdesc:ab28f2f1c7bbf2861f4a3e7602a317b96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the end.    <br /></td></tr>
<tr class="separator:ab28f2f1c7bbf2861f4a3e7602a317b96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbdc51681af75f7cf4303d17a689a601"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1basic__sparse__set.html#a6cea231ae7386a12487164d918f632b0">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#afbdc51681af75f7cf4303d17a689a601">find</a> (const <a class="el" href="classentt_1_1basic__sparse__set.html#ae90adeddf9bab1f9c8b4b1fff95980f0">entity_type</a> entt) const noexcept</td></tr>
<tr class="memdesc:afbdc51681af75f7cf4303d17a689a601"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds an entity.  <br /></td></tr>
<tr class="separator:afbdc51681af75f7cf4303d17a689a601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97b47cbaea3fc30442fa3e6366766c86"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#a97b47cbaea3fc30442fa3e6366766c86">contains</a> (const <a class="el" href="classentt_1_1basic__sparse__set.html#ae90adeddf9bab1f9c8b4b1fff95980f0">entity_type</a> entt) const noexcept</td></tr>
<tr class="memdesc:a97b47cbaea3fc30442fa3e6366766c86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a sparse set contains an entity.  <br /></td></tr>
<tr class="separator:a97b47cbaea3fc30442fa3e6366766c86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96cf0ed9f37ededbd40f6a8c38c1940b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1basic__sparse__set.html#a14e627591924feaaad4f04d13c4f4b2d">version_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#a96cf0ed9f37ededbd40f6a8c38c1940b">current</a> (const <a class="el" href="classentt_1_1basic__sparse__set.html#ae90adeddf9bab1f9c8b4b1fff95980f0">entity_type</a> entt) const noexcept</td></tr>
<tr class="memdesc:a96cf0ed9f37ededbd40f6a8c38c1940b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the contained version for an identifier.  <br /></td></tr>
<tr class="separator:a96cf0ed9f37ededbd40f6a8c38c1940b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8a8fc74771c26b36fce8234f5e1d1fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1basic__sparse__set.html#a2ec9530d8aa9ac94d421b27eb6998edb">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#ad8a8fc74771c26b36fce8234f5e1d1fa">index</a> (const <a class="el" href="classentt_1_1basic__sparse__set.html#ae90adeddf9bab1f9c8b4b1fff95980f0">entity_type</a> entt) const noexcept</td></tr>
<tr class="memdesc:ad8a8fc74771c26b36fce8234f5e1d1fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the position of an entity in a sparse set.  <br /></td></tr>
<tr class="separator:ad8a8fc74771c26b36fce8234f5e1d1fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace1aab87bce23a757d40c5366ec2222e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1basic__sparse__set.html#ae90adeddf9bab1f9c8b4b1fff95980f0">entity_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#ace1aab87bce23a757d40c5366ec2222e">at</a> (const <a class="el" href="classentt_1_1basic__sparse__set.html#a2ec9530d8aa9ac94d421b27eb6998edb">size_type</a> pos) const noexcept</td></tr>
<tr class="memdesc:ace1aab87bce23a757d40c5366ec2222e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the entity at specified location, with bounds checking.  <br /></td></tr>
<tr class="separator:ace1aab87bce23a757d40c5366ec2222e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba848e5d30f1f8fadce544d7bba7296a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1basic__sparse__set.html#ae90adeddf9bab1f9c8b4b1fff95980f0">entity_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#aba848e5d30f1f8fadce544d7bba7296a">operator[]</a> (const <a class="el" href="classentt_1_1basic__sparse__set.html#a2ec9530d8aa9ac94d421b27eb6998edb">size_type</a> pos) const noexcept</td></tr>
<tr class="memdesc:aba848e5d30f1f8fadce544d7bba7296a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the entity at specified location, without bounds checking.  <br /></td></tr>
<tr class="separator:aba848e5d30f1f8fadce544d7bba7296a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3725f4fb86b9bb73f5f397884ff1680"><td class="memItemLeft" align="right" valign="top">const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#ab3725f4fb86b9bb73f5f397884ff1680">value</a> (const <a class="el" href="classentt_1_1basic__sparse__set.html#ae90adeddf9bab1f9c8b4b1fff95980f0">entity_type</a> entt) const noexcept</td></tr>
<tr class="memdesc:ab3725f4fb86b9bb73f5f397884ff1680"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the element assigned to an entity, if any.  <br /></td></tr>
<tr class="separator:ab3725f4fb86b9bb73f5f397884ff1680"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a319f3827fb68d33cddbdb5519723ea6f"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#a319f3827fb68d33cddbdb5519723ea6f">value</a> (const <a class="el" href="classentt_1_1basic__sparse__set.html#ae90adeddf9bab1f9c8b4b1fff95980f0">entity_type</a> entt) noexcept</td></tr>
<tr class="memdesc:a319f3827fb68d33cddbdb5519723ea6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the element assigned to an entity, if any.    <br /></td></tr>
<tr class="separator:a319f3827fb68d33cddbdb5519723ea6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cf01b2a8d20329ec1c1d5d3b5708969"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1basic__sparse__set.html#a6cea231ae7386a12487164d918f632b0">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#a8cf01b2a8d20329ec1c1d5d3b5708969">push</a> (const <a class="el" href="classentt_1_1basic__sparse__set.html#ae90adeddf9bab1f9c8b4b1fff95980f0">entity_type</a> entt, const void *elem=nullptr)</td></tr>
<tr class="memdesc:a8cf01b2a8d20329ec1c1d5d3b5708969"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns an entity to a sparse set.  <br /></td></tr>
<tr class="separator:a8cf01b2a8d20329ec1c1d5d3b5708969"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43205b128298f90d1255cf4ce768297c"><td class="memTemplParams" colspan="2">template&lt;typename It &gt; </td></tr>
<tr class="memitem:a43205b128298f90d1255cf4ce768297c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1basic__sparse__set.html#a6cea231ae7386a12487164d918f632b0">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#a43205b128298f90d1255cf4ce768297c">push</a> (It first, It last)</td></tr>
<tr class="memdesc:a43205b128298f90d1255cf4ce768297c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns one or more entities to a sparse set.  <br /></td></tr>
<tr class="separator:a43205b128298f90d1255cf4ce768297c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a777ecee811e5fa5567bc462dba476771"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1basic__sparse__set.html#a14e627591924feaaad4f04d13c4f4b2d">version_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#a777ecee811e5fa5567bc462dba476771">bump</a> (const <a class="el" href="classentt_1_1basic__sparse__set.html#ae90adeddf9bab1f9c8b4b1fff95980f0">entity_type</a> entt)</td></tr>
<tr class="memdesc:a777ecee811e5fa5567bc462dba476771"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bump the version number of an entity.  <br /></td></tr>
<tr class="separator:a777ecee811e5fa5567bc462dba476771"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a41589e81003ca86b8a6104842680cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#a0a41589e81003ca86b8a6104842680cb">erase</a> (const <a class="el" href="classentt_1_1basic__sparse__set.html#ae90adeddf9bab1f9c8b4b1fff95980f0">entity_type</a> entt)</td></tr>
<tr class="memdesc:a0a41589e81003ca86b8a6104842680cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases an entity from a sparse set.  <br /></td></tr>
<tr class="separator:a0a41589e81003ca86b8a6104842680cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f3bad1bb267d515e61fd717f4dbb011"><td class="memTemplParams" colspan="2">template&lt;typename It &gt; </td></tr>
<tr class="memitem:a1f3bad1bb267d515e61fd717f4dbb011"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#a1f3bad1bb267d515e61fd717f4dbb011">erase</a> (It first, It last)</td></tr>
<tr class="memdesc:a1f3bad1bb267d515e61fd717f4dbb011"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases entities from a set.  <br /></td></tr>
<tr class="separator:a1f3bad1bb267d515e61fd717f4dbb011"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af02e5833d5edb2450303bd1c029213b8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#af02e5833d5edb2450303bd1c029213b8">remove</a> (const <a class="el" href="classentt_1_1basic__sparse__set.html#ae90adeddf9bab1f9c8b4b1fff95980f0">entity_type</a> entt)</td></tr>
<tr class="memdesc:af02e5833d5edb2450303bd1c029213b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes an entity from a sparse set if it exists.  <br /></td></tr>
<tr class="separator:af02e5833d5edb2450303bd1c029213b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2b4ee6c81e845f332c35c89acb8f436"><td class="memTemplParams" colspan="2">template&lt;typename It &gt; </td></tr>
<tr class="memitem:ab2b4ee6c81e845f332c35c89acb8f436"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1basic__sparse__set.html#a2ec9530d8aa9ac94d421b27eb6998edb">size_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#ab2b4ee6c81e845f332c35c89acb8f436">remove</a> (It first, It last)</td></tr>
<tr class="memdesc:ab2b4ee6c81e845f332c35c89acb8f436"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes entities from a sparse set if they exist.  <br /></td></tr>
<tr class="separator:ab2b4ee6c81e845f332c35c89acb8f436"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4979ce48546cfcc705c4d23654faef2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#af4979ce48546cfcc705c4d23654faef2">compact</a> ()</td></tr>
<tr class="memdesc:af4979ce48546cfcc705c4d23654faef2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all tombstones from a sparse set.  <br /></td></tr>
<tr class="separator:af4979ce48546cfcc705c4d23654faef2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b82af720eca37261f3230c654d7fe1f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#a2b82af720eca37261f3230c654d7fe1f">swap_elements</a> (const <a class="el" href="classentt_1_1basic__sparse__set.html#ae90adeddf9bab1f9c8b4b1fff95980f0">entity_type</a> lhs, const <a class="el" href="classentt_1_1basic__sparse__set.html#ae90adeddf9bab1f9c8b4b1fff95980f0">entity_type</a> rhs)</td></tr>
<tr class="memdesc:a2b82af720eca37261f3230c654d7fe1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps two entities in a sparse set.  <br /></td></tr>
<tr class="separator:a2b82af720eca37261f3230c654d7fe1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43c1c0aa0fa525e12cee0791cd945915"><td class="memTemplParams" colspan="2">template&lt;typename Compare , typename Sort  = std_sort, typename... Args&gt; </td></tr>
<tr class="memitem:a43c1c0aa0fa525e12cee0791cd945915"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#a43c1c0aa0fa525e12cee0791cd945915">sort_n</a> (const <a class="el" href="classentt_1_1basic__sparse__set.html#a2ec9530d8aa9ac94d421b27eb6998edb">size_type</a> length, Compare compare, Sort algo=Sort{}, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a43c1c0aa0fa525e12cee0791cd945915"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort the first count elements according to the given comparison function.  <br /></td></tr>
<tr class="separator:a43c1c0aa0fa525e12cee0791cd945915"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7ceed81905adc0d65291eb9f4072f08"><td class="memTemplParams" colspan="2">template&lt;typename Compare , typename Sort  = std_sort, typename... Args&gt; </td></tr>
<tr class="memitem:ae7ceed81905adc0d65291eb9f4072f08"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#ae7ceed81905adc0d65291eb9f4072f08">sort</a> (Compare compare, Sort algo=Sort{}, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:ae7ceed81905adc0d65291eb9f4072f08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort all elements according to the given comparison function.  <br /></td></tr>
<tr class="separator:ae7ceed81905adc0d65291eb9f4072f08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a785d2733c7087fba3c03612403094420"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#a785d2733c7087fba3c03612403094420">sort_as</a> (const <a class="el" href="classentt_1_1basic__sparse__set.html">basic_sparse_set</a> &amp;other)</td></tr>
<tr class="memdesc:a785d2733c7087fba3c03612403094420"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort entities according to their order in another sparse set.  <br /></td></tr>
<tr class="separator:a785d2733c7087fba3c03612403094420"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6560773b887906122d50a413aea1faad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#a6560773b887906122d50a413aea1faad">clear</a> ()</td></tr>
<tr class="memdesc:a6560773b887906122d50a413aea1faad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears a sparse set.  <br /></td></tr>
<tr class="separator:a6560773b887906122d50a413aea1faad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae37830b84f2801670927b8ae881d72b7"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structentt_1_1type__info.html">type_info</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#ae37830b84f2801670927b8ae881d72b7">type</a> () const noexcept</td></tr>
<tr class="memdesc:ae37830b84f2801670927b8ae881d72b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returned value type, if any.  <br /></td></tr>
<tr class="separator:ae37830b84f2801670927b8ae881d72b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9db791610e0925291f9213681b0d4a9f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#a9db791610e0925291f9213681b0d4a9f">bind</a> (<a class="el" href="namespaceentt.html#a4846741b8f485584c196304f588b94ad">any</a>) noexcept</td></tr>
<tr class="memdesc:a9db791610e0925291f9213681b0d4a9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forwards variables to derived classes, if any.  <br /></td></tr>
<tr class="separator:a9db791610e0925291f9213681b0d4a9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-types" name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:ac56bb654b47a648d64a754d85c70b40a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#ac56bb654b47a648d64a754d85c70b40a">basic_iterator</a> = internal::sparse_set_iterator&lt; packed_container_type &gt;</td></tr>
<tr class="memdesc:ac56bb654b47a648d64a754d85c70b40a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Random access iterator type.  <br /></td></tr>
<tr class="separator:ac56bb654b47a648d64a754d85c70b40a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:aece8d1b71906967491ee44f9374e20d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#aece8d1b71906967491ee44f9374e20d2">swap_at</a> (const std::size_t lhs, const std::size_t rhs)</td></tr>
<tr class="memdesc:aece8d1b71906967491ee44f9374e20d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps two items at specific locations.  <br /></td></tr>
<tr class="separator:aece8d1b71906967491ee44f9374e20d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b95c0acd8af718e712362d1177dbc1e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#a2b95c0acd8af718e712362d1177dbc1e">swap_and_pop</a> (const <a class="el" href="classentt_1_1basic__sparse__set.html#ac56bb654b47a648d64a754d85c70b40a">basic_iterator</a> it)</td></tr>
<tr class="memdesc:a2b95c0acd8af718e712362d1177dbc1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases an entity from a sparse set.  <br /></td></tr>
<tr class="separator:a2b95c0acd8af718e712362d1177dbc1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa45b7ab945ade01c286a35cba5376d7f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#aa45b7ab945ade01c286a35cba5376d7f">in_place_pop</a> (const <a class="el" href="classentt_1_1basic__sparse__set.html#ac56bb654b47a648d64a754d85c70b40a">basic_iterator</a> it)</td></tr>
<tr class="memdesc:aa45b7ab945ade01c286a35cba5376d7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases an entity from a sparse set.  <br /></td></tr>
<tr class="separator:aa45b7ab945ade01c286a35cba5376d7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f66cbcaa360286d296dcb7a33c7e1ce"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#a8f66cbcaa360286d296dcb7a33c7e1ce">pop</a> (<a class="el" href="classentt_1_1basic__sparse__set.html#ac56bb654b47a648d64a754d85c70b40a">basic_iterator</a> first, <a class="el" href="classentt_1_1basic__sparse__set.html#ac56bb654b47a648d64a754d85c70b40a">basic_iterator</a> last)</td></tr>
<tr class="memdesc:a8f66cbcaa360286d296dcb7a33c7e1ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases entities from a sparse set.  <br /></td></tr>
<tr class="separator:a8f66cbcaa360286d296dcb7a33c7e1ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e8e00e8bfa75311482f2fa071e244e6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#a1e8e00e8bfa75311482f2fa071e244e6">pop_all</a> ()</td></tr>
<tr class="memdesc:a1e8e00e8bfa75311482f2fa071e244e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases all entities of a sparse set.  <br /></td></tr>
<tr class="separator:a1e8e00e8bfa75311482f2fa071e244e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c62d9615acde55f57fcca92e44c747c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classentt_1_1basic__sparse__set.html#ac56bb654b47a648d64a754d85c70b40a">basic_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#a1c62d9615acde55f57fcca92e44c747c">try_emplace</a> (const Entity entt, const bool force_back, const void *=nullptr)</td></tr>
<tr class="memdesc:a1c62d9615acde55f57fcca92e44c747c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns an entity to a sparse set.  <br /></td></tr>
<tr class="separator:a1c62d9615acde55f57fcca92e44c747c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename Entity, typename Allocator&gt;<br />
class entt::basic_sparse_set&lt; Entity, Allocator &gt;</div><p>Basic sparse set implementation. </p>
<p>Sparse set or packed array or whatever is the name users give it.<br  />
 Two arrays: an <em>external</em> one and an <em>internal</em> one; a <em>sparse</em> one and a <em>packed</em> one; one used for direct access through contiguous memory, the other one used to get the data through an extra level of indirection.<br  />
 This type of data structure is widely documented in the literature and on the web. This is nothing more than a customized implementation suitable for the purpose of the framework.</p>
<dl class="section note"><dt>Note</dt><dd>Internal data structures arrange elements to maximize performance. There are no guarantees that entities are returned in the insertion order when iterate a sparse set. Do not make assumption on the order in any case.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Entity</td><td>A valid entity type. </td></tr>
    <tr><td class="paramname">Allocator</td><td>Type of allocator used to manage memory and elements. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00166">166</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="af6faaccfb0c465afb6173b0fb8a37069" name="af6faaccfb0c465afb6173b0fb8a37069"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6faaccfb0c465afb6173b0fb8a37069">&#9670;&#160;</a></span>allocator_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::allocator_type =  Allocator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocator type. </p>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00339">339</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<a id="ac56bb654b47a648d64a754d85c70b40a" name="ac56bb654b47a648d64a754d85c70b40a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac56bb654b47a648d64a754d85c70b40a">&#9670;&#160;</a></span>basic_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::basic_iterator =  internal::sparse_set_iterator&lt;packed_container_type&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Random access iterator type. </p>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00228">228</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<a id="a3688979d568f2450725d69aa89571f4f" name="a3688979d568f2450725d69aa89571f4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3688979d568f2450725d69aa89571f4f">&#9670;&#160;</a></span>const_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::const_iterator =  <a class="el" href="classentt_1_1basic__sparse__set.html#a6cea231ae7386a12487164d918f632b0">iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constant random access iterator type. </p>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00345">345</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<a id="a27d66fda0fba1587a5f61e9c16f742f7" name="a27d66fda0fba1587a5f61e9c16f742f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27d66fda0fba1587a5f61e9c16f742f7">&#9670;&#160;</a></span>const_reverse_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::const_reverse_iterator =  std::reverse_iterator&lt;<a class="el" href="classentt_1_1basic__sparse__set.html#a3688979d568f2450725d69aa89571f4f">const_iterator</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constant reverse iterator type. </p>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00349">349</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<a id="ae90adeddf9bab1f9c8b4b1fff95980f0" name="ae90adeddf9bab1f9c8b4b1fff95980f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae90adeddf9bab1f9c8b4b1fff95980f0">&#9670;&#160;</a></span>entity_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::entity_type =  typename <a class="el" href="classentt_1_1basic__entt__traits.html#a8d3ccdc302fc7dc567541fa12eca6b4e">traits_type::value_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Underlying entity identifier. </p>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00333">333</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<a id="a6cea231ae7386a12487164d918f632b0" name="a6cea231ae7386a12487164d918f632b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cea231ae7386a12487164d918f632b0">&#9670;&#160;</a></span>iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::iterator =  <a class="el" href="classentt_1_1basic__sparse__set.html#ac56bb654b47a648d64a754d85c70b40a">basic_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Random access iterator type. </p>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00343">343</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<a id="a8b18963e68d4f003e19389fd342f90cc" name="a8b18963e68d4f003e19389fd342f90cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b18963e68d4f003e19389fd342f90cc">&#9670;&#160;</a></span>pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::pointer =  typename packed_container_type::const_pointer</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pointer type to contained entities. </p>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00341">341</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<a id="afe62c143e816cf5e12078a607966c003" name="afe62c143e816cf5e12078a607966c003"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe62c143e816cf5e12078a607966c003">&#9670;&#160;</a></span>reverse_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::reverse_iterator =  std::reverse_iterator&lt;<a class="el" href="classentt_1_1basic__sparse__set.html#a6cea231ae7386a12487164d918f632b0">iterator</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reverse iterator type. </p>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00347">347</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<a id="a2ec9530d8aa9ac94d421b27eb6998edb" name="a2ec9530d8aa9ac94d421b27eb6998edb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ec9530d8aa9ac94d421b27eb6998edb">&#9670;&#160;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::size_type =  std::size_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unsigned integer type. </p>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00337">337</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<a id="ac1f56bb6b949b338ddad09977c631706" name="ac1f56bb6b949b338ddad09977c631706"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1f56bb6b949b338ddad09977c631706">&#9670;&#160;</a></span>traits_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::traits_type =  <a class="el" href="structentt_1_1entt__traits.html">entt_traits</a>&lt;Entity&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Entity traits. </p>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00331">331</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<a id="a14e627591924feaaad4f04d13c4f4b2d" name="a14e627591924feaaad4f04d13c4f4b2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14e627591924feaaad4f04d13c4f4b2d">&#9670;&#160;</a></span>version_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::version_type =  typename <a class="el" href="classentt_1_1basic__entt__traits.html#aa3fe33d19b228d07c5560b907f910c10">traits_type::version_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Underlying version type. </p>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00335">335</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="afc504894fc2c20ea25b7fc2864bd22e3" name="afc504894fc2c20ea25b7fc2864bd22e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc504894fc2c20ea25b7fc2864bd22e3">&#9670;&#160;</a></span>basic_sparse_set() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::basic_sparse_set </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. </p>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00352">352</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<a id="a1b636566df9e6f3f36ff62d2bdde8d10" name="a1b636566df9e6f3f36ff62d2bdde8d10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b636566df9e6f3f36ff62d2bdde8d10">&#9670;&#160;</a></span>basic_sparse_set() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::basic_sparse_set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__sparse__set.html#af6faaccfb0c465afb6173b0fb8a37069">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>allocator</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs an empty container with a given allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allocator</td><td>The allocator to use. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00359">359</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<a id="a8e264ab5a7e2d97a204004d25b14238b" name="a8e264ab5a7e2d97a204004d25b14238b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e264ab5a7e2d97a204004d25b14238b">&#9670;&#160;</a></span>basic_sparse_set() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::basic_sparse_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceentt.html#abc4d0fa77fae26e7c01793990996c581">deletion_policy</a>&#160;</td>
          <td class="paramname"><em>pol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__sparse__set.html#af6faaccfb0c465afb6173b0fb8a37069">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>allocator</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs an empty container with the given policy and allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pol</td><td>Type of deletion policy. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use (possibly default-constructed). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00367">367</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<a id="af5d35aae661fb35e485ac733969c84d9" name="af5d35aae661fb35e485ac733969c84d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5d35aae661fb35e485ac733969c84d9">&#9670;&#160;</a></span>basic_sparse_set() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::basic_sparse_set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structentt_1_1type__info.html">type_info</a> &amp;&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceentt.html#abc4d0fa77fae26e7c01793990996c581">deletion_policy</a>&#160;</td>
          <td class="paramname"><em>pol</em> = <code><a class="el" href="namespaceentt.html#abc4d0fa77fae26e7c01793990996c581a8223d1ccb16b6dd0b19fe9c6fdb13708">deletion_policy::swap_and_pop</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__sparse__set.html#af6faaccfb0c465afb6173b0fb8a37069">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>allocator</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs an empty container with the given value type, policy and allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">elem</td><td>Returned value type, if any. </td></tr>
    <tr><td class="paramname">pol</td><td>Type of deletion policy. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use (possibly default-constructed). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00377">377</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<a id="aaf4d881833f592ed21079e2a0fac8d2a" name="aaf4d881833f592ed21079e2a0fac8d2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf4d881833f592ed21079e2a0fac8d2a">&#9670;&#160;</a></span>basic_sparse_set() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::basic_sparse_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classentt_1_1basic__sparse__set.html">basic_sparse_set</a>&lt; Entity, Allocator &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The instance to move from. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00388">388</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<a id="a8c61f0d7c13b938d3524f0fe7f9c3a75" name="a8c61f0d7c13b938d3524f0fe7f9c3a75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c61f0d7c13b938d3524f0fe7f9c3a75">&#9670;&#160;</a></span>basic_sparse_set() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::basic_sparse_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classentt_1_1basic__sparse__set.html">basic_sparse_set</a>&lt; Entity, Allocator &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__sparse__set.html#af6faaccfb0c465afb6173b0fb8a37069">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocator-extended move constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The instance to move from. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00400">400</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<a id="ac56f048f614c38f14b19ba9cb27faa94" name="ac56f048f614c38f14b19ba9cb27faa94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac56f048f614c38f14b19ba9cb27faa94">&#9670;&#160;</a></span>~basic_sparse_set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::~<a class="el" href="classentt_1_1basic__sparse__set.html">basic_sparse_set</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default destructor. </p>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00410">410</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ace1aab87bce23a757d40c5366ec2222e" name="ace1aab87bce23a757d40c5366ec2222e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace1aab87bce23a757d40c5366ec2222e">&#9670;&#160;</a></span>at()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1basic__sparse__set.html#ae90adeddf9bab1f9c8b4b1fff95980f0">entity_type</a> <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::at </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__sparse__set.html#a2ec9530d8aa9ac94d421b27eb6998edb">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the entity at specified location, with bounds checking. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The position for which to return the entity. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The entity at specified location if any, a null entity otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00656">656</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<a id="af6e986a41090a43eb6bbdc22bf8eb472" name="af6e986a41090a43eb6bbdc22bf8eb472"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6e986a41090a43eb6bbdc22bf8eb472">&#9670;&#160;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1basic__sparse__set.html#a3688979d568f2450725d69aa89571f4f">const_iterator</a> <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the beginning. </p>
<p>If the sparse set is empty, the returned iterator will be equal to <code><a class="el" href="classentt_1_1basic__sparse__set.html#a3187a76bdb963346a715e0ebd833bfd7" title="Returns an iterator to the end.">end()</a></code>.</p>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the first entity of the sparse set. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00546">546</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<a id="a9db791610e0925291f9213681b0d4a9f" name="a9db791610e0925291f9213681b0d4a9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9db791610e0925291f9213681b0d4a9f">&#9670;&#160;</a></span>bind()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::bind </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceentt.html#a4846741b8f485584c196304f588b94ad">any</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Forwards variables to derived classes, if any. </p>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00985">985</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<a id="a777ecee811e5fa5567bc462dba476771" name="a777ecee811e5fa5567bc462dba476771"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a777ecee811e5fa5567bc462dba476771">&#9670;&#160;</a></span>bump()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1basic__sparse__set.html#a14e627591924feaaad4f04d13c4f4b2d">version_type</a> <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::bump </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__sparse__set.html#ae90adeddf9bab1f9c8b4b1fff95980f0">entity_type</a>&#160;</td>
          <td class="paramname"><em>entt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bump the version number of an entity. </p>
<dl class="section warning"><dt>Warning</dt><dd>Attempting to bump the version of an entity that doesn't belong to the sparse set results in undefined behavior.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entt</td><td>A valid identifier. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The version of the given identifier. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00737">737</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<a id="a17b25baaceb061cd93da56f1ec24ee98" name="a17b25baaceb061cd93da56f1ec24ee98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17b25baaceb061cd93da56f1ec24ee98">&#9670;&#160;</a></span>capacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classentt_1_1basic__sparse__set.html#a2ec9530d8aa9ac94d421b27eb6998edb">size_type</a> <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements that a sparse set has currently allocated space for. </p>
<dl class="section return"><dt>Returns</dt><dd>Capacity of the sparse set. </dd></dl>

<p>Reimplemented in <a class="el" href="classentt_1_1basic__storage.html#a45d9ea8409804572c0ec705c2bc8c293">entt::basic_storage&lt; Type, Entity, Allocator, typename &gt;</a>, and <a class="el" href="classentt_1_1basic__storage.html#a45d9ea8409804572c0ec705c2bc8c293">entt::basic_storage&lt; Mask, Registry::entity_type, Allocator &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00477">477</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<a id="a1934fc85ed01c3528c45ab9a76712fa7" name="a1934fc85ed01c3528c45ab9a76712fa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1934fc85ed01c3528c45ab9a76712fa7">&#9670;&#160;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1basic__sparse__set.html#a3688979d568f2450725d69aa89571f4f">const_iterator</a> <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the beginning.   </p>
<p>If the sparse set is empty, the returned iterator will be equal to <code><a class="el" href="classentt_1_1basic__sparse__set.html#a3187a76bdb963346a715e0ebd833bfd7" title="Returns an iterator to the end.">end()</a></code>.</p>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the first entity of the sparse set.   </dd></dl>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00552">552</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<a id="a9f0cc6e746fd49b0c7a0b8e5d8504fef" name="a9f0cc6e746fd49b0c7a0b8e5d8504fef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f0cc6e746fd49b0c7a0b8e5d8504fef">&#9670;&#160;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1basic__sparse__set.html#a3688979d568f2450725d69aa89571f4f">const_iterator</a> <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the end.   </p>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the element following the last entity of a sparse set.   </dd></dl>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00566">566</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<a id="a6560773b887906122d50a413aea1faad" name="a6560773b887906122d50a413aea1faad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6560773b887906122d50a413aea1faad">&#9670;&#160;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears a sparse set. </p>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00968">968</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<a id="af4979ce48546cfcc705c4d23654faef2" name="af4979ce48546cfcc705c4d23654faef2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4979ce48546cfcc705c4d23654faef2">&#9670;&#160;</a></span>compact()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::compact </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all tombstones from a sparse set. </p>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00824">824</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<a id="a97b47cbaea3fc30442fa3e6366766c86" name="a97b47cbaea3fc30442fa3e6366766c86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97b47cbaea3fc30442fa3e6366766c86">&#9670;&#160;</a></span>contains()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__sparse__set.html#ae90adeddf9bab1f9c8b4b1fff95980f0">entity_type</a>&#160;</td>
          <td class="paramname"><em>entt</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if a sparse set contains an entity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entt</td><td>A valid identifier. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the sparse set contains the entity, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00617">617</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<a id="a736ba15d734ea65f18e3c1fd5d748e5e" name="a736ba15d734ea65f18e3c1fd5d748e5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a736ba15d734ea65f18e3c1fd5d748e5e">&#9670;&#160;</a></span>contiguous()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::contiguous </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether a sparse set is fully packed. </p>
<dl class="section return"><dt>Returns</dt><dd>True if the sparse set is fully packed, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00526">526</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<a id="ad57b82c12d92837a14d8904e82eb49a9" name="ad57b82c12d92837a14d8904e82eb49a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad57b82c12d92837a14d8904e82eb49a9">&#9670;&#160;</a></span>crbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1basic__sparse__set.html#a27d66fda0fba1587a5f61e9c16f742f7">const_reverse_iterator</a> <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::crbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the beginning.   </p>
<p>If the sparse set is empty, the returned iterator will be equal to <code><a class="el" href="classentt_1_1basic__sparse__set.html#a408ae201025279196f63ef32cf58da9a" title="Returns a reverse iterator to the end.">rend()</a></code>.</p>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the first entity of the reversed internal packed array.   </dd></dl>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00584">584</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<a id="ab28f2f1c7bbf2861f4a3e7602a317b96" name="ab28f2f1c7bbf2861f4a3e7602a317b96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab28f2f1c7bbf2861f4a3e7602a317b96">&#9670;&#160;</a></span>crend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1basic__sparse__set.html#a27d66fda0fba1587a5f61e9c16f742f7">const_reverse_iterator</a> <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::crend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the end.   </p>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the element following the last entity of the reversed sparse set.   </dd></dl>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00598">598</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<a id="a96cf0ed9f37ededbd40f6a8c38c1940b" name="a96cf0ed9f37ededbd40f6a8c38c1940b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96cf0ed9f37ededbd40f6a8c38c1940b">&#9670;&#160;</a></span>current()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1basic__sparse__set.html#a14e627591924feaaad4f04d13c4f4b2d">version_type</a> <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::current </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__sparse__set.html#ae90adeddf9bab1f9c8b4b1fff95980f0">entity_type</a>&#160;</td>
          <td class="paramname"><em>entt</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the contained version for an identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entt</td><td>A valid identifier. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The version for the given identifier if present, the tombstone version otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00630">630</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<a id="a4c540ff32bca204b1adbd9e4f4a0240b" name="a4c540ff32bca204b1adbd9e4f4a0240b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c540ff32bca204b1adbd9e4f4a0240b">&#9670;&#160;</a></span>data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1basic__sparse__set.html#a8b18963e68d4f003e19389fd342f90cc">pointer</a> <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Direct access to the internal packed array. </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the internal packed array. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00534">534</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<a id="ad8936d80c3656449118a7a7a08be6258" name="ad8936d80c3656449118a7a7a08be6258"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8936d80c3656449118a7a7a08be6258">&#9670;&#160;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether a sparse set is empty. </p>
<dl class="section return"><dt>Returns</dt><dd>True if the sparse set is empty, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00518">518</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<a id="a3187a76bdb963346a715e0ebd833bfd7" name="a3187a76bdb963346a715e0ebd833bfd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3187a76bdb963346a715e0ebd833bfd7">&#9670;&#160;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1basic__sparse__set.html#a6cea231ae7386a12487164d918f632b0">iterator</a> <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the end. </p>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the element following the last entity of a sparse set. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00561">561</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<a id="a0a41589e81003ca86b8a6104842680cb" name="a0a41589e81003ca86b8a6104842680cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a41589e81003ca86b8a6104842680cb">&#9670;&#160;</a></span>erase() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__sparse__set.html#ae90adeddf9bab1f9c8b4b1fff95980f0">entity_type</a>&#160;</td>
          <td class="paramname"><em>entt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erases an entity from a sparse set. </p>
<dl class="section warning"><dt>Warning</dt><dd>Attempting to erase an entity that doesn't belong to the sparse set results in undefined behavior.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entt</td><td>A valid identifier. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00754">754</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<a id="a1f3bad1bb267d515e61fd717f4dbb011" name="a1f3bad1bb267d515e61fd717f4dbb011"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f3bad1bb267d515e61fd717f4dbb011">&#9670;&#160;</a></span>erase() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<div class="memtemplate">
template&lt;typename It &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">It&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">It&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erases entities from a set. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classentt_1_1basic__sparse__set.html#a0a41589e81003ca86b8a6104842680cb" title="Erases an entity from a sparse set.">erase</a></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">It</td><td>Type of input iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>An iterator to the first element of the range of entities. </td></tr>
    <tr><td class="paramname">last</td><td>An iterator past the last element of the range of entities. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00769">769</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<a id="a7e51c3904b0581866f8791a04435fc5f" name="a7e51c3904b0581866f8791a04435fc5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e51c3904b0581866f8791a04435fc5f">&#9670;&#160;</a></span>extent()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1basic__sparse__set.html#a2ec9530d8aa9ac94d421b27eb6998edb">size_type</a> <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::extent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the extent of a sparse set. </p>
<p>The extent of a sparse set is also the size of the internal sparse array. There is no guarantee that the internal packed array has the same size. Usually the size of the internal sparse array is equal or greater than the one of the internal packed array.</p>
<dl class="section return"><dt>Returns</dt><dd>Extent of the sparse set. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00496">496</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<a id="afbdc51681af75f7cf4303d17a689a601" name="afbdc51681af75f7cf4303d17a689a601"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbdc51681af75f7cf4303d17a689a601">&#9670;&#160;</a></span>find()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1basic__sparse__set.html#a6cea231ae7386a12487164d918f632b0">iterator</a> <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__sparse__set.html#ae90adeddf9bab1f9c8b4b1fff95980f0">entity_type</a>&#160;</td>
          <td class="paramname"><em>entt</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds an entity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entt</td><td>A valid identifier. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the given entity if it's found, past the end iterator otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00608">608</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<a id="ab292b60dd8782739701906aec8f381ab" name="ab292b60dd8782739701906aec8f381ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab292b60dd8782739701906aec8f381ab">&#9670;&#160;</a></span>get_allocator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classentt_1_1basic__sparse__set.html#af6faaccfb0c465afb6173b0fb8a37069">allocator_type</a> <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::get_allocator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the associated allocator. </p>
<dl class="section return"><dt>Returns</dt><dd>The associated allocator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00448">448</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<a id="aa45b7ab945ade01c286a35cba5376d7f" name="aa45b7ab945ade01c286a35cba5376d7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa45b7ab945ade01c286a35cba5376d7f">&#9670;&#160;</a></span>in_place_pop()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::in_place_pop </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__sparse__set.html#ac56bb654b47a648d64a754d85c70b40a">basic_iterator</a>&#160;</td>
          <td class="paramname"><em>it</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erases an entity from a sparse set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>An iterator to the element to pop. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00267">267</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<a id="ad8a8fc74771c26b36fce8234f5e1d1fa" name="ad8a8fc74771c26b36fce8234f5e1d1fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8a8fc74771c26b36fce8234f5e1d1fa">&#9670;&#160;</a></span>index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1basic__sparse__set.html#a2ec9530d8aa9ac94d421b27eb6998edb">size_type</a> <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::index </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__sparse__set.html#ae90adeddf9bab1f9c8b4b1fff95980f0">entity_type</a>&#160;</td>
          <td class="paramname"><em>entt</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the position of an entity in a sparse set. </p>
<dl class="section warning"><dt>Warning</dt><dd>Attempting to get the position of an entity that doesn't belong to the sparse set results in undefined behavior.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entt</td><td>A valid identifier. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The position of the entity in the sparse set. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00646">646</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<a id="a53f8aad7f89c040a3ef0e79ad9e814fb" name="a53f8aad7f89c040a3ef0e79ad9e814fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53f8aad7f89c040a3ef0e79ad9e814fb">&#9670;&#160;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1basic__sparse__set.html">basic_sparse_set</a> &amp; <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classentt_1_1basic__sparse__set.html">basic_sparse_set</a>&lt; Entity, Allocator &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The instance to move from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This sparse set. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00419">419</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<a id="aba848e5d30f1f8fadce544d7bba7296a" name="aba848e5d30f1f8fadce544d7bba7296a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba848e5d30f1f8fadce544d7bba7296a">&#9670;&#160;</a></span>operator[]()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1basic__sparse__set.html#ae90adeddf9bab1f9c8b4b1fff95980f0">entity_type</a> <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__sparse__set.html#a2ec9530d8aa9ac94d421b27eb6998edb">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the entity at specified location, without bounds checking. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The position for which to return the entity. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The entity at specified location. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00665">665</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<a id="a91f80e4333c16c6c3786b041c8a7e8a2" name="a91f80e4333c16c6c3786b041c8a7e8a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91f80e4333c16c6c3786b041c8a7e8a2">&#9670;&#160;</a></span>policy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceentt.html#abc4d0fa77fae26e7c01793990996c581">deletion_policy</a> <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::policy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the deletion policy of a sparse set. </p>
<dl class="section return"><dt>Returns</dt><dd>The deletion policy of the sparse set. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00456">456</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<a id="a8f66cbcaa360286d296dcb7a33c7e1ce" name="a8f66cbcaa360286d296dcb7a33c7e1ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f66cbcaa360286d296dcb7a33c7e1ce">&#9670;&#160;</a></span>pop()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::pop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classentt_1_1basic__sparse__set.html#ac56bb654b47a648d64a754d85c70b40a">basic_iterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classentt_1_1basic__sparse__set.html#ac56bb654b47a648d64a754d85c70b40a">basic_iterator</a>&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erases entities from a sparse set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>An iterator to the first element of the range of entities. </td></tr>
    <tr><td class="paramname">last</td><td>An iterator past the last element of the range of entities. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classentt_1_1basic__storage.html#ab2d0f02c4c0a88d6fe42b95e9c2b8226">entt::basic_storage&lt; Type, Entity, Allocator, typename &gt;</a>, <a class="el" href="classentt_1_1basic__storage.html#ab2d0f02c4c0a88d6fe42b95e9c2b8226">entt::basic_storage&lt; Mask, Registry::entity_type, Allocator &gt;</a>, and <a class="el" href="classentt_1_1basic__storage_3_01Entity_00_01Entity_00_01Allocator_01_4.html#aa65a1f2501a186f571184ef6fff7100d">entt::basic_storage&lt; Entity, Entity, Allocator &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00279">279</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<a id="a1e8e00e8bfa75311482f2fa071e244e6" name="a1e8e00e8bfa75311482f2fa071e244e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e8e00e8bfa75311482f2fa071e244e6">&#9670;&#160;</a></span>pop_all()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::pop_all </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erases all entities of a sparse set. </p>

<p>Reimplemented in <a class="el" href="classentt_1_1basic__storage.html#a343212f5eacd1e124fb85be1a6841b60">entt::basic_storage&lt; Type, Entity, Allocator, typename &gt;</a>, <a class="el" href="classentt_1_1basic__storage.html#a343212f5eacd1e124fb85be1a6841b60">entt::basic_storage&lt; Mask, Registry::entity_type, Allocator &gt;</a>, and <a class="el" href="classentt_1_1basic__storage_3_01Entity_00_01Entity_00_01Allocator_01_4.html#a4703e670597bf8dfebe036f8a378ca12">entt::basic_storage&lt; Entity, Entity, Allocator &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00292">292</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<a id="a8cf01b2a8d20329ec1c1d5d3b5708969" name="a8cf01b2a8d20329ec1c1d5d3b5708969"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cf01b2a8d20329ec1c1d5d3b5708969">&#9670;&#160;</a></span>push() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1basic__sparse__set.html#a6cea231ae7386a12487164d918f632b0">iterator</a> <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::push </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__sparse__set.html#ae90adeddf9bab1f9c8b4b1fff95980f0">entity_type</a>&#160;</td>
          <td class="paramname"><em>entt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>elem</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns an entity to a sparse set. </p>
<dl class="section warning"><dt>Warning</dt><dd>Attempting to assign an entity that already belongs to the sparse set results in undefined behavior.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entt</td><td>A valid identifier. </td></tr>
    <tr><td class="paramname">elem</td><td>Optional opaque element to forward to mixins, if any. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator pointing to the emplaced element in case of success, the <code><a class="el" href="classentt_1_1basic__sparse__set.html#a3187a76bdb963346a715e0ebd833bfd7" title="Returns an iterator to the end.">end()</a></code> iterator otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00701">701</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<a id="a43205b128298f90d1255cf4ce768297c" name="a43205b128298f90d1255cf4ce768297c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43205b128298f90d1255cf4ce768297c">&#9670;&#160;</a></span>push() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<div class="memtemplate">
template&lt;typename It &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1basic__sparse__set.html#a6cea231ae7386a12487164d918f632b0">iterator</a> <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::push </td>
          <td>(</td>
          <td class="paramtype">It&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">It&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns one or more entities to a sparse set. </p>
<dl class="section warning"><dt>Warning</dt><dd>Attempting to assign an entity that already belongs to the sparse set results in undefined behavior.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">It</td><td>Type of input iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>An iterator to the first element of the range of entities. </td></tr>
    <tr><td class="paramname">last</td><td>An iterator past the last element of the range of entities. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator pointing to the first element inserted in case of success, the <code><a class="el" href="classentt_1_1basic__sparse__set.html#a3187a76bdb963346a715e0ebd833bfd7" title="Returns an iterator to the end.">end()</a></code> iterator otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00719">719</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<a id="a365e15bdab3308c58af3c03376cce1ec" name="a365e15bdab3308c58af3c03376cce1ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a365e15bdab3308c58af3c03376cce1ec">&#9670;&#160;</a></span>rbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1basic__sparse__set.html#a27d66fda0fba1587a5f61e9c16f742f7">const_reverse_iterator</a> <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the beginning. </p>
<p>If the sparse set is empty, the returned iterator will be equal to <code><a class="el" href="classentt_1_1basic__sparse__set.html#a408ae201025279196f63ef32cf58da9a" title="Returns a reverse iterator to the end.">rend()</a></code>.</p>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the first entity of the reversed internal packed array. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00579">579</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<a id="af02e5833d5edb2450303bd1c029213b8" name="af02e5833d5edb2450303bd1c029213b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af02e5833d5edb2450303bd1c029213b8">&#9670;&#160;</a></span>remove() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::remove </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__sparse__set.html#ae90adeddf9bab1f9c8b4b1fff95980f0">entity_type</a>&#160;</td>
          <td class="paramname"><em>entt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes an entity from a sparse set if it exists. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entt</td><td>A valid identifier. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the entity is actually removed, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00784">784</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<a id="ab2b4ee6c81e845f332c35c89acb8f436" name="ab2b4ee6c81e845f332c35c89acb8f436"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2b4ee6c81e845f332c35c89acb8f436">&#9670;&#160;</a></span>remove() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<div class="memtemplate">
template&lt;typename It &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1basic__sparse__set.html#a2ec9530d8aa9ac94d421b27eb6998edb">size_type</a> <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::remove </td>
          <td>(</td>
          <td class="paramtype">It&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">It&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes entities from a sparse set if they exist. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">It</td><td>Type of input iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>An iterator to the first element of the range of entities. </td></tr>
    <tr><td class="paramname">last</td><td>An iterator past the last element of the range of entities. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of entities actually removed. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00796">796</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<a id="a408ae201025279196f63ef32cf58da9a" name="a408ae201025279196f63ef32cf58da9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a408ae201025279196f63ef32cf58da9a">&#9670;&#160;</a></span>rend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1basic__sparse__set.html#afe62c143e816cf5e12078a607966c003">reverse_iterator</a> <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the end. </p>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the element following the last entity of the reversed sparse set. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00593">593</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<a id="a58d49df52ee3133a1347dc01131a4f1a" name="a58d49df52ee3133a1347dc01131a4f1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58d49df52ee3133a1347dc01131a4f1a">&#9670;&#160;</a></span>reserve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__sparse__set.html#a2ec9530d8aa9ac94d421b27eb6998edb">size_type</a>&#160;</td>
          <td class="paramname"><em>cap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increases the capacity of a sparse set. </p>
<p>If the new capacity is greater than the current capacity, new storage is allocated, otherwise the method does nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cap</td><td>Desired capacity. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classentt_1_1basic__storage.html#ad51850043e05582865e5c93fa06421be">entt::basic_storage&lt; Type, Entity, Allocator, typename &gt;</a>, and <a class="el" href="classentt_1_1basic__storage.html#ad51850043e05582865e5c93fa06421be">entt::basic_storage&lt; Mask, Registry::entity_type, Allocator &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00468">468</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<a id="a7e10cc6ddc7ef9c733aabdec849c5b79" name="a7e10cc6ddc7ef9c733aabdec849c5b79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e10cc6ddc7ef9c733aabdec849c5b79">&#9670;&#160;</a></span>shrink_to_fit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::shrink_to_fit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Requests the removal of unused capacity. </p>

<p>Reimplemented in <a class="el" href="classentt_1_1basic__storage.html#ad569287dadaa314c700f0e904ef71409">entt::basic_storage&lt; Type, Entity, Allocator, typename &gt;</a>, and <a class="el" href="classentt_1_1basic__storage.html#ad569287dadaa314c700f0e904ef71409">entt::basic_storage&lt; Mask, Registry::entity_type, Allocator &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00482">482</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<a id="a69ad0662838fd351985a51ee3017fb6c" name="a69ad0662838fd351985a51ee3017fb6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69ad0662838fd351985a51ee3017fb6c">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1basic__sparse__set.html#a2ec9530d8aa9ac94d421b27eb6998edb">size_type</a> <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements in a sparse set. </p>
<p>The number of elements is also the size of the internal packed array. There is no guarantee that the internal sparse array has the same size. Usually the size of the internal sparse array is equal or greater than the one of the internal packed array.</p>
<dl class="section return"><dt>Returns</dt><dd>Number of elements. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00510">510</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<a id="ae7ceed81905adc0d65291eb9f4072f08" name="ae7ceed81905adc0d65291eb9f4072f08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7ceed81905adc0d65291eb9f4072f08">&#9670;&#160;</a></span>sort()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<div class="memtemplate">
template&lt;typename Compare , typename Sort  = std_sort, typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::sort </td>
          <td>(</td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>compare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sort&#160;</td>
          <td class="paramname"><em>algo</em> = <code>Sort{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sort all elements according to the given comparison function. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classentt_1_1basic__sparse__set.html#a43c1c0aa0fa525e12cee0791cd945915" title="Sort the first count elements according to the given comparison function.">sort_n</a></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Compare</td><td>Type of comparison function object. </td></tr>
    <tr><td class="paramname">Sort</td><td>Type of sort function object. </td></tr>
    <tr><td class="paramname">Args</td><td>Types of arguments to forward to the sort function object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">compare</td><td>A valid comparison function object. </td></tr>
    <tr><td class="paramname">algo</td><td>A valid sort function object. </td></tr>
    <tr><td class="paramname">args</td><td>Arguments to forward to the sort function object, if any. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00934">934</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<a id="a785d2733c7087fba3c03612403094420" name="a785d2733c7087fba3c03612403094420"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a785d2733c7087fba3c03612403094420">&#9670;&#160;</a></span>sort_as()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::sort_as </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__sparse__set.html">basic_sparse_set</a>&lt; Entity, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sort entities according to their order in another sparse set. </p>
<p>Entities that are part of both the sparse sets are ordered internally according to the order they have in <code>other</code>.<br  />
 All the other entities goes to the end of the list and there are no guarantees on their order.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The sparse sets that imposes the order of the entities. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00949">949</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<a id="a43c1c0aa0fa525e12cee0791cd945915" name="a43c1c0aa0fa525e12cee0791cd945915"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43c1c0aa0fa525e12cee0791cd945915">&#9670;&#160;</a></span>sort_n()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<div class="memtemplate">
template&lt;typename Compare , typename Sort  = std_sort, typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::sort_n </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__sparse__set.html#a2ec9530d8aa9ac94d421b27eb6998edb">size_type</a>&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>compare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sort&#160;</td>
          <td class="paramname"><em>algo</em> = <code>Sort{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sort the first count elements according to the given comparison function. </p>
<p>The comparison function object must return <code>true</code> if the first element is <em>less</em> than the second one, <code>false</code> otherwise. The signature of the comparison function should be equivalent to the following:</p>
<div class="fragment"><div class="line">bool(<span class="keyword">const</span> Entity, <span class="keyword">const</span> Entity);</div>
</div><!-- fragment --><p>Moreover, the comparison function object shall induce a <em>strict weak ordering</em> on the values.</p>
<p>The sort function object must offer a member function template <code>operator()</code> that accepts three arguments:</p>
<ul>
<li>An iterator to the first element of the range to sort.</li>
<li>An iterator past the last element of the range to sort.</li>
<li>A comparison function to use to compare the elements.</li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Compare</td><td>Type of comparison function object. </td></tr>
    <tr><td class="paramname">Sort</td><td>Type of sort function object. </td></tr>
    <tr><td class="paramname">Args</td><td>Types of arguments to forward to the sort function object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">length</td><td>Number of elements to sort. </td></tr>
    <tr><td class="paramname">compare</td><td>A valid comparison function object. </td></tr>
    <tr><td class="paramname">algo</td><td>A valid sort function object. </td></tr>
    <tr><td class="paramname">args</td><td>Arguments to forward to the sort function object, if any. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00899">899</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<a id="a0ba4866849ffb525cce7b4eee58b83a8" name="a0ba4866849ffb525cce7b4eee58b83a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ba4866849ffb525cce7b4eee58b83a8">&#9670;&#160;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classentt_1_1basic__sparse__set.html">basic_sparse_set</a>&lt; Entity, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Exchanges the contents with those of a given sparse set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Sparse set to exchange the content with. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00435">435</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<a id="a2b95c0acd8af718e712362d1177dbc1e" name="a2b95c0acd8af718e712362d1177dbc1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b95c0acd8af718e712362d1177dbc1e">&#9670;&#160;</a></span>swap_and_pop()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::swap_and_pop </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__sparse__set.html#ac56bb654b47a648d64a754d85c70b40a">basic_iterator</a>&#160;</td>
          <td class="paramname"><em>it</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erases an entity from a sparse set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>An iterator to the element to pop. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00250">250</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<a id="aece8d1b71906967491ee44f9374e20d2" name="aece8d1b71906967491ee44f9374e20d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aece8d1b71906967491ee44f9374e20d2">&#9670;&#160;</a></span>swap_at()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::swap_at </td>
          <td>(</td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps two items at specific locations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>A position to move from. </td></tr>
    <tr><td class="paramname">rhs</td><td>The other position to move from. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00235">235</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<a id="a2b82af720eca37261f3230c654d7fe1f" name="a2b82af720eca37261f3230c654d7fe1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b82af720eca37261f3230c654d7fe1f">&#9670;&#160;</a></span>swap_elements()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::swap_elements </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__sparse__set.html#ae90adeddf9bab1f9c8b4b1fff95980f0">entity_type</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__sparse__set.html#ae90adeddf9bab1f9c8b4b1fff95980f0">entity_type</a>&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps two entities in a sparse set. </p>
<p>For what it's worth, this function affects both the internal sparse array and the internal packed array. Users should not care of that anyway.</p>
<dl class="section warning"><dt>Warning</dt><dd>Attempting to swap entities that don't belong to the sparse set results in undefined behavior.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>A valid identifier. </td></tr>
    <tr><td class="paramname">rhs</td><td>A valid identifier. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00859">859</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<a id="a1c62d9615acde55f57fcca92e44c747c" name="a1c62d9615acde55f57fcca92e44c747c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c62d9615acde55f57fcca92e44c747c">&#9670;&#160;</a></span>try_emplace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classentt_1_1basic__sparse__set.html#ac56bb654b47a648d64a754d85c70b40a">basic_iterator</a> <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::try_emplace </td>
          <td>(</td>
          <td class="paramtype">const Entity&#160;</td>
          <td class="paramname"><em>entt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>force_back</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns an entity to a sparse set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entt</td><td>A valid identifier. </td></tr>
    <tr><td class="paramname">force_back</td><td>Force back insertion. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator pointing to the emplaced element. </dd></dl>

<p>Reimplemented in <a class="el" href="classentt_1_1basic__storage.html#a96a10490c949af09275a303e7d352f9a">entt::basic_storage&lt; Type, Entity, Allocator, typename &gt;</a>, and <a class="el" href="classentt_1_1basic__storage_3_01Entity_00_01Entity_00_01Allocator_01_4.html#a70ee247f23204a7cd323968a19adf91e">entt::basic_storage&lt; Entity, Entity, Allocator &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00314">314</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<a id="ae37830b84f2801670927b8ae881d72b7" name="ae37830b84f2801670927b8ae881d72b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae37830b84f2801670927b8ae881d72b7">&#9670;&#160;</a></span>type()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structentt_1_1type__info.html">type_info</a> &amp; <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returned value type, if any. </p>
<dl class="section return"><dt>Returns</dt><dd>Returned value type, if any. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00980">980</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<a id="ab3725f4fb86b9bb73f5f397884ff1680" name="ab3725f4fb86b9bb73f5f397884ff1680"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3725f4fb86b9bb73f5f397884ff1680">&#9670;&#160;</a></span>value() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const void * <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__sparse__set.html#ae90adeddf9bab1f9c8b4b1fff95980f0">entity_type</a>&#160;</td>
          <td class="paramname"><em>entt</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the element assigned to an entity, if any. </p>
<dl class="section warning"><dt>Warning</dt><dd>Attempting to use an entity that doesn't belong to the sparse set results in undefined behavior.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entt</td><td>A valid identifier. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An opaque pointer to the element assigned to the entity, if any. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00680">680</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<a id="a319f3827fb68d33cddbdb5519723ea6f" name="a319f3827fb68d33cddbdb5519723ea6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a319f3827fb68d33cddbdb5519723ea6f">&#9670;&#160;</a></span>value() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__sparse__set.html#ae90adeddf9bab1f9c8b4b1fff95980f0">entity_type</a>&#160;</td>
          <td class="paramname"><em>entt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the element assigned to an entity, if any.   </p>
<dl class="section warning"><dt>Warning</dt><dd>Attempting to use an entity that doesn't belong to the sparse set results in undefined behavior.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entt</td><td>A valid identifier. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An opaque pointer to the element assigned to the entity, if any.   </dd></dl>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00685">685</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/entt/entity/<a class="el" href="entity_2fwd_8hpp_source.html">fwd.hpp</a></li>
<li>src/entt/entity/<a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6
</small></address>
</body>
</html>
